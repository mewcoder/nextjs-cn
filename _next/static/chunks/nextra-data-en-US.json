{"/docs/app":{"title":"App Router","data":{"":"App Router 是使用 React 最新特性来构建应用程序的新范式。如果你已经熟悉 Next.js 你会发现 App Router 是现有基于文件系统的路由在 Pages Router 中的自然演进。对于新的应用程序，我们推荐使用 App Router。对于现有应用程序，你可以 渐进地迁移到 App Router。本文档的这部分包括了 App Router 中的可用特性。"}},"/docs/architecture/accessibility":{"title":"无障碍","data":{"":"Next.js 团队致力于让 Next.js 对所有开发者(以及终端用户)都可无障碍。通过在 Next.js 中默认添加无障碍功能,我们旨在让网络对每个人都更具包容性。","路由播报#路由播报":"在服务器渲染的页面之间切换时(例如使用<a href>标签)，屏幕阅读器和其他辅助技术会在页面加载时播报页面标题，以便用户了解页面已经改变。除了传统的页面导航之外，Next.js 还支持客户端过渡以提高性能(使用next/link)。为了确保客户端过渡也被播报给辅助技术，Next.js 默认包含一个路由播报器。Next.js 路由播报器会先检查 document.title，然后是<h1>元素，最后是 URL 路径名，以查找要播报的页面名称。为了获得最可无障碍的用户体验，请确保应用程序中的每个页面都有一个独特且描述明确的标题。","代码规范#代码规范":"Next.js 提供了开箱即用的集成 ESLint 体验，包括 Next.js 的自定义规则。默认情况下，Next.js 包含eslint-plugin-jsx-a11y以帮助尽早发现无障碍问题，包括对以下方面发出警告:\naria-props\naria-proptypes\naria-unsupported-elements\nrole-has-required-aria-props\nrole-supports-aria-props\n例如，这个插件可以帮助确保为img标签添加 alt 文本,使用正确的aria-*属性，使用正确的role属性等。","无障碍资源#无障碍资源":"WebAIM WCAG 检查表\nWCAG 2.1 指南\nA11y 项目\n检查前景色和背景色之间的 色彩对比度 between foreground and background elements\n在使用动画时采用 prefers-reduced-motion"}},"/docs/architecture/fast-refresh":{"title":"快速刷新","data":{"":"示例\nFast Refresh Demo\n快速刷新 (Fast Refresh) 是 Next.js 的一个功能，可以即时反馈你对 React 组件所做的编辑。在 9.4 或更高版本的所有 Next.js 应用中，默认启用了快速刷新。启用了 Next.js 快速刷新后，大多数编辑应该在一秒内可见，且不会丢失组件状态。","工作原理#工作原理":"如果你编辑的文件只导出 React 组件，则快速刷新只会更新该文件的代码,并重新渲染你的组件。你可以编辑该文件中的任何内容，包括样式、渲染逻辑、事件处理程序或效果。\n如果你编辑的文件导出的不是 React 组件，则快速刷新会重新运行该文件以及导入它的其他文件。因此,如果 Button.js 和 Modal.js 都导入了 theme.js，编辑 theme.js 将更新这两个组件。\n最后，如果你 编辑的文件 被 React 树外的文件导入，则快速刷新会退回到完全重载。你可能有一个文件既渲染 React 组件，又导出一个被非 React 组件导入的常量。例如，你的组件可能还导出一个常量，一个非 React 实用程序文件导入它。在这种情况下，考虑将该常量迁移到一个单独的文件中，并在两个文件中导入它。这将重新启用快速刷新。其他情况通常也可以以类似的方式解决。","错误恢复#错误恢复":"","语法错误#语法错误":"如果你在开发过程中产生语法错误，可以修复它并再次保存文件。错误将自动消失，所以你不需要重新加载应用程序。你不会丢失组件状态。","运行时错误#运行时错误":"如果你的组件内部出现导致运行时错误的错误,你将看到一个上下文覆盖提示。修复错误将自动关闭覆盖提示,而无需重新加载应用程序。如果错误不是在渲染期间发生的,组件状态将会保留。如果错误确实是在渲染期间发生的,React 将使用更新后的代码重新挂载你的应用程序。如果你的应用程序中有错误边界(这在生产环境中的优雅失败是个好主意),它们会在渲染错误后的下一次编辑中重新尝试渲染。这意味着错误边界可以避免你总是重置到根应用程序状态。然而,请记住错误边界不应该太细颗粒化。它们在生产环境中由 React 使用,并且应该始终有意设计。","限制#限制":"快速刷新会尽量在你编辑的组件中保留本地 React 状态,但前提是这么做是安全的。以下是你可能会在每次编辑文件时看到本地状态被重置的一些原因:\n本地状态不会为类组件保留(只有函数组件和 Hooks 保留状态)。\n你编辑的文件可能除了 React 组件之外还有其他导出。\n有时,一个文件会导出调用高阶组件的结果,如 HOC(WrappedComponent) 。如果返回的组件是类组件,其状态将被重置。\n如 export default () => <div />; 这样的匿名箭头函数会导致快速刷新无法保留本地组件状态。对于大型代码库,你可以使用我们的 name-default-component 代码修改器。\n随着代码库中越来越多的代码迁移到函数组件和 Hooks,你可以期待状态在更多情况下得以保留。","提示#提示":"快速刷新默认会在函数组件(和 Hooks)中保留 React 本地状态。\n有时你可能希望强制重置状态,并重新挂载一个组件。例如,如果你正在调整只在挂载时发生的动画,这可能会很方便。为此,你可以在正在编辑的文件中的任何位置添加 // @refresh reset。这个指令是针对本地文件的,它指示快速刷新在每次编辑时重新挂载文件中定义的组件。\n你可以在开发期间编辑的组件中放入 console.log 或 debugger;","快速刷新和-hooks#快速刷新和 Hooks":"在可能的情况下，快速刷新会尝试在两次编辑之间保留组件的状态。具体而言，只要不改变的参数或 Hook 调用的顺序， useState and useRef 就会保留它们先前的值。具有依赖关系的 Hook - 如useEffect， useMemo, 和 useCallback - 在快速刷新期间总会更新。它们的依赖关系列表在快速刷新发生时会被忽略。例如,当你将 useMemo(() => x * 2, [x]) 编辑为 useMemo(() => x * 10, [x]) 时，即使 x (依赖关系)没有改变，它也会重新运行。如果 React 不这样做，你的编辑就不会反映在页面上!有时,这可能会导致意外的结果。例如，即使 useEffect 有一个空的依赖关系数组，在快速刷新期间它也会重新运行一次。但是，即使在没有快速刷新的情况下，编写能够偶尔重新运行 useEffect 的稳健代码也是个好习惯。这将使你以后更容易向其中引入新依赖项，并且这也是 React 严格模式 所强制执行的，我们强烈建议启用它。"}},"/docs/architecture":{"title":"架构","data":{"":"了解Next.js的架构及其底层工作原理。"}},"/docs/architecture/turbopack":{"title":"Turbopack","data":{"":"Turbopack (beta)是一个针对 JavaScript 和 TypeScript 优化的增量打包器,使用 Rust 编写,并内置于 Next.js 中。","使用#使用":"Turbopack 可以在 Next.js 的 pages 和 app 目录中用于更快的本地开发。要启用 Turbopack,在运行 Next.js 开发服务器时使用 --turbo 标志。\n{\n  \"scripts\": {\n    \"dev\": \"next dev --turbo\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\"\n  }\n}","支持的功能#支持的功能":"要了解 Turbopack 当前支持的功能,请查看文档。","不支持的功能#不支持的功能":"Turbopack 目前仅支持 next dev，不支持 next build。我们正在努力在逐步走向稳定版本的过程中支持构建。"}},"/docs/community/contribution-guide":{"title":"文档贡献指南","data":{"":"欢迎来到 Next.js 文档贡献指南！我们很高兴你能来到这里。本页提供如何编辑 Next.js 文档的说明。我们的目标是确保社区中的每个人都有能力贡献和改进我们的文档。","为什么贡献#为什么贡献?":"开源工作永无止境，文档工作也是如此。向文档投稿是初学者参与开源的好方法，也是经验丰富的开发者在与社区分享知识的同时阐明较复杂问题的好途径。通过向 Next.js 文档做贡献，你将帮助我们为所有开发人员构建更强大的学习资源。无论你是发现了一个错字、一个困惑的部分，还是意识到缺少了一个特定主题，我们都欢迎并感谢你的贡献。","如何贡献#如何贡献":"文档内容可以在 Next.js repo 中找到。 要进行贡献，你可以直接在 GitHub 上编辑文件，或者克隆存储库并在本地编辑文件。","github-workflow#GitHub Workflow":"如果你是 GitHub 的新手，我们建议你阅读 GitHub Open Source Guide 学习如何 fork 仓库, 创建分支, 和提交 pull request.\n小贴士: 底层的 docs 代码存在于一个私有代码库中，该代码库与 Next.js 公共代码库同步。这意味着你无法在本地预览文档。但是，合并 pull request 后，你将在 nextjs.org 上看到你的更改。","编写-mdx#编写 MDX":"文档是用 MDX 编写的, MDX 是一种支持 JSX 语法的 markdown 格式。允许我们在文档中嵌入 React 组件。 请参阅 GitHub Markdown Guide 快速了解 Markdown 语法","vscode#VSCode":"","本地预览更改#本地预览更改":"VSCode 有一个内置的 markdown 预览器，你可以使用它在本地查看你的编辑。若要启用 MDX 文件的预览器，你需要在用户设置中添加一个配置选项。打开命令面板 (Mac 上的⌘ + ⇧ + P 或 Windows 上的 Ctrl + Shift + P) 然后从 Preferences: Open User Settings (JSON) 开始搜索.然后，将以下添加到 settings.json 文件中:\n{\n  \"files.associations\": {\n    \"*.mdx\": \"markdown\"\n  }\n}\n接下来，再次打开命令面板，搜索 Markdown: Preview File 或者 Markdown: Open Preview to the Side. 这将打开一个预览窗口，你可以在其中看到格式化后的更改。","插件#插件":"我们还建议 VSCode 用户使用以下插件：\nMDX: MDX 的智能提示和语法高亮显示。\nGrammarly: 语法和拼写检查。\nPrettier: 在保存时格式化 MDX 文件。","review-流程#Review 流程":"一旦你提交了你的贡献，Next.js 或 Developer Experience 团队将 review 你的更改，提供反馈，并在准备好后合并 pull request。如果你有任何问题或需要进一步帮助，请在 PR 的评论中告知我们。感谢你为 Next.js 文档做出贡献，并成为我们社区的一员！\n提示: 在提交 PR 之前，执行 pnpm prettier-fix 运行 Prettier","文件结构#文件结构":"文档使用文件系统路由。 /docs 内的每个文件夹和文件代表一个路由段。这些段用于生成 URL 路径、导航和面包屑。文件结构反映了你在站点上看到的导航，默认情况下，导航项按字母顺序排序。但是，我们可以通过在文件夹或文件名前添加两位数字 (00-) 来更改项目的顺序。例如，在 functions API 参考 中，页面按字母顺序排序，因为这样开发人员可以更容易地找到特定的函数：\n03-functions\n├── cookies.mdx\n├── draft-mode.mdx\n├── fetch.mdx\n└── ...\n但是，在 routing 章节，文件前缀为两位数的数字，按照开发人员应该学习这些概念的顺序排序：\n02-routing\n├── 01-defining-routes.mdx\n├── 02-pages-and-layouts.mdx\n├── 03-linking-and-navigating.mdx\n└── ...\n要快速查找页面，你可以使用 ⌘ + P (Mac) 或 Ctrl + P (Windows)打开 VSCode 上的搜索栏。然后输入要查找的页面的标题。例如 defining-routes\n为什么不用 manifest?我们考虑过使用 manifest 文件（另一种流行的生成文档导航的方法），但我们发现 manifest 文件会很快与文件不同步。文件系统路由迫使我们考虑文档的结构，而且感觉更适合 Next.js","元数据#元数据":"每个页面在文件的顶部都有一个元数据块，由三个破折号分隔。","必填字段#必填字段":"以下字段为必填:\n字段\t描述\ttitle\t页面的 <h1> 标题, 用于 SEO 和 OG 图像。\tdescription\t页面的描述，用于 SEO 的 <meta name=\"description\"> 标签。\t\n---\ntile: Page Title\ndescription: Page Description\n---\n最好将页面标题限制在 2-3 个词语（例如：优化图像）和描述为 1-2 个句子（例如了解如何在 Next.js 中优化图像）","可选字段#可选字段":"以下字段为可选:\nField\tDescription\tnav_title\t覆盖导航中的页面标题。当页面标题太长而无法容纳时，这很有用。如果未提供，则使用 title 字段。\tsource\t将内容拉入共享页面。请看共享页面。\trelated\t文档底部的相关页面列表。它们会自动变成卡片。请看 相关链接。\t\n---\nnav_title: Nav Item Title\nsource: app/building-your-application/optimizing/images\nrelated:\n  description: See the image component API reference.\n  links:\n    - app/api-reference/components/image\n---","app-和-pages-文档#App 和 Pages 文档":"由于 App Router 和 Pages Router 的大部分功能完全不同，因此它们的文档被分别放在不同的部分(02-app 和 03-pages)。不过，它们之间也有一些共享的特性。","共享页面#共享页面":"为了避免内容重复和内容不同步的风险，我们使用 source 字段将内容从一个页面拉到另一个页面。例如， the <Link>组件在 App 和 Pages中的行为基本相同。我们可以将内容从app/.../link.mdx 拉到 pages/.../link.mdx，而不是复制内容。\n---\ntitle: <Link>\ndescription: <Link> 组件的 API 参考\n---\n本 API 参考将帮助您了解如何使用 Link 组件的道具和 Link 组件可用的配置选项。\n---\ntitle: <Link>\ndescription: <Link> 组件的 API 参考\nsource: app/api-reference/components/link\n---\n{/* 不要编辑此页 */}\n{/* 本页内容从 source 拉取 */}\n因此，我们可以在一个地方编辑内容，并在两个版块中反映出来。","共享内容#共享内容":"在共享页面中，有时可能会有 App Router 或 Pages Router 特定的内容。例如， <Link> 组件有一个shallow 属性，只有在 Pages 中可用，而在 App 中则不可用。为了确保内容只显示在正确的路由中，我们可以用 <AppOnly> 或 <PagesOnly> 组件来封装内容块：\n这些内容在 App 和 Pages 共享。\n<PagesOnly>\n这些内容只会在 Pages 中显示。\n</PagesOnly>\n这些内容在 App 和 Pages 共享。\n你可能会在示例和代码块中使用这些组件。","代码块#代码块":"代码块应至少包含一个可复制和粘贴的工作示例。这意味着代码应无需任何额外配置即可运行。例如，如果要演示如何使用 <Link> 组件，则应包含 import 语句和 <Link> 组件本身。\nimport Link from \"next/link\";\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>;\n}\n在提交示例之前，请务必在本地运行示例。这将确保代码是最新的并能正常运行。","语言和文件名#语言和文件名":"代码块应有一个包含语言和 filename 的标题。添加 filename 属性以渲染一个特殊的终端图标，帮助用户确定输入命令的位置。例如：\n```bash filename=\"Terminal\"\nnpx create-next-app\n```\n档中的大多数示例都是用 tsx 和 jsx 编写的，还有一些是用 bash 编写的。不过，您也可以使用任何支持的语言, 以下是完整的语言列表 full list.在编写 JavaScript 代码块时，我们使用以下语言和扩展组合。\n\tLanguage\t后缀名\t包含 JSX 的 JavaScript 文件\t```jsx\t.js\t不含 JSX 的 JavaScript 文件\t```js\t.js\t包含 JSX 的 TypeScript 文件\t```tsx\t.tsx\t不含 JSX 的 TypeScript 文件\t```ts\t.ts","ts-和-js-切换器#TS 和 JS 切换器":"添加语言切换器，以便在 TypeScript 和 JavaScript 之间切换。代码块应首先使用 TypeScript，然后再使用 JavaScript 版本，以方便用户使用。目前，我们一个接一个地编写 TS 和 JS 示例，并用 switcher 属性将它们连接起来:\n```tsx filename=\"app/page.tsx\" switcher\n```\n```jsx filename=\"app/page.js\" switcher\n```\n小贴士: 我们计划将来将 TypeScript 片段自动编译为 JavaScript。在此期间，您可以使用 transform.tools。","行高亮#行高亮":"代码行可以高亮显示。当你想让别人注意到代码的某个特定部分时，这很有用。您可以通过向 highlight 属性传递数字来突出显示行.单行: highlight={1}\nimport Link from \"next/link\";\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>;\n}\n多行: highlight={1,3}\nimport Link from \"next/link\";\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>;\n}\n行范围: highlight={1-5}\nimport Link from \"next/link\";\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>;\n}","图标#图标":"以下图标可在文档中使用：\n<Check size={18} />\n<Cross size={18} />\nOutput:\n我们不在文档中使用 emoji 表情。","注释#注释":"对于重要但不关键的信息，可使用注释。注释是添加信息的好方法，不会分散用户对主要内容的注意力。\n> **小贴士**: 这是一个单行注释。\n> **小贴士**:\n>\n> - 我们也会使用这种格式进行多行注释。\n> - 有时候会有多个值得注意或谨记的要点。\nOutput:\n小贴士: 这是一个单行注释。\n小贴士:\n我们也会使用这种格式进行多行注释。\n有时候会有多个值得注意或谨记的要点。","相关链接#相关链接":"相关链接通过提供合适的下一步链接来指导用户的学习过程。\n链接将以卡片形式显示在页面主内容之下。\n有子页面的页面会自动生成链接。例如，优化 章节就有指向其所有子页面的链接.\n使用页面元数据中的 related 字段创建相关链接\n---\nrelated:\n  description: Learn how to quickly get started with your first application.\n  links:\n    - app/building-your-application/routing/defining-routes\n    - app/building-your-application/data-fetching\n    - app/api-reference/file-conventions/page\n---","嵌套字段#嵌套字段":"字段\t是否必选?\t描述\ttitle\t可选\t卡片列表的标题。默认为下一步。\tdescription\t可选\t卡片列表的描述。\tlinks\t必选\t指向其他文档页面的链接列表。每个列表项都应是一个相对 URL 路径(不含最前面的斜线)，例如 app/api-reference/file-conventions/page","图表#图表":"图表是解释复杂概念的好方法。我们按照 Vercel 的设计指南使用 Figma 创建图表。这些图表目前保存在我们私有 Next.js 站点的 /public 文件夹中。如果您想更新或添加图表，请创建 GitHub issue。","自定义组件和-html#自定义组件和 HTML":"这些是文档中可用的 React 组件: <Image /> (next/image)， <PagesOnly />，<AppOnly />，<Cross /> 和 <Check />。 我们不允许在文档中使用 <details>如果您有关于新组件的想法，请创建 GitHub issue.","风格指南#风格指南":"本节包含针对技术写作新手的文档写作指南。","页面模板#页面模板":"虽然我们没有严格的页面模板，但你会在文档中看到重复出现的页面部分：\n概述: 页面的第一段应告诉用户该功能是什么，有什么用途。然后是一个最基本的用例或 API 参考\n约定: 如果功能有约定，则应在此处加以说明.\n示例: 展示如何在不同的用例中使用该功能。\nAPI 表: API 页面应在页面顶部有一个概览表，并尽可能提供跳转到各节的链接。\n下一步 (相关链接): 添加相关页面链接，引导用户学习。\n根据需要添加这些部分。","页面类型#页面类型":"文档页面也分为两类： 概念性和参考性\n概念性 页面用于解释概念或特性。它们通常比参考页更长，包含更多的信息。在 Next.js 文档中，概念性页面位于 构建应用程序 章节。\n参考性 页面用于解释特定的 API。 它们通常更简短，更聚焦。在 Next.js 文档中，参考性页面位于 API 参考 章节。\n小贴士: 你可能需要使用不同的语言和风格。例如，概念性页面更具指导性，使用 \"你 \"来称呼用户。而参考性页面则更具技术性，使用 \"创建、更新、接受\" 等命令式词语，并倾向于省略 \"你\" 这个词。","语气#语气":"以下是维持文档语气和风格一致的几点指导原则:\n使用简明的语句，避免散乱的内容。\n如果你发现自己使用了很多逗号，考虑将其分解为多个句子，或使用列表。\n使用简单的词汇代替复杂的词汇。例如,使用 use 而不是 utilize。\n慎用 this 一词,它可能含糊不清,引起困惑。如有不清楚的地方，不要害怕重复使用主语。\n例如，使用 Next.js uses React 而不是 Next.js uses this。\n使用主动语态而不是被动语态。主动语态更容易阅读。\n例如，使用 Next.js uses React 而不是 React is used by Next.js 。如果你发现自己使用了 was 和 by ，可能是使用了被动语态。\n避免使用 easy，quick，simple，just 等主观性词汇，这可能会让用户感到气馁。\n避免使用 don't， can't， won't 等否定词汇，这也可能会让用户感到气馁。\n例如，\"You can use the Link component to create links between pages\"，而不是 \"Don't use the <a> tag to create links between pages\" 。\n使用第二人称( you / your )。这样更个性化，也更有吸引力。\n使用性别中立的语言。提到受众时使用 developers，users 或 readers 。\n如果添加代码示例，请确保其格式正确且可运行。\n尽管这些指导原则并不详尽，但它们应该可以帮助你开始着手。如果你想更深入地了解技术写作，可以查看 Google 技术写作教程。感谢您为文档做出贡献，并成为 Next.js 社区的一员！"}},"/docs/community":{"title":"Next.js 社区","data":{"":"Next.js 的每周下载量超过 400 万次，拥有遍布全球庞大而活跃的开发者社区。以下是你可以参与我们社区的一些方式：","贡献#贡献":"你可以通过以下几种方式贡献 Next.js 的开发：\n文档：建议改进或者编写新的章节，帮助我们的用户了解如何使用 Next.js。\n示例：通过创建新的示例或改进现有示例，帮助开发人员将 Next.js 与其他工具和服务集成。\n代码库：了解有关底层架构的更多信息，帮助修复漏洞和错误，并提出新功能建议。","讨论#讨论":"如果你有关于 Next.js 的问题，或希望帮助他人，欢迎随时加入对话：\nGitHub 讨论\nDiscord\nReddit","社交媒体#社交媒体":"关注 Next.js 在 Twitter 上的最新更新，并订阅 Vercel 的 YouTube 频道 获取 Next.js 的视频。","行为准则#行为准则":"我们致力于创建一个包容、热情的社区。因此，我们要求所有成员遵守我们的行为准则。该文档概述了我们对参与者行为的期望。我们邀请您阅读并帮助我们维持一个安全和相互尊重的环境."}},"/docs/getting-started/installation":{"title":"安装","data":{"":"系统要求：\nNode.js 16.14 或更高版本。\n支持 macOS，Windows（包括 WSL）和 Linux。","自动安装#自动安装":"我们建议使用create-next-app创建一个新的 Next.js 应用，它会为你自动设置好所有东西。要创建一个项目，请运行：\nnpx create-next-app@latest\n在安装时，将看到以下提示：\nWhat is your project named? my-app\nWould you like to use TypeScript? No / Yes\nWould you like to use ESLint? No / Yes\nWould you like to use Tailwind CSS? No / Yes\nWould you like to use `src/` directory? No / Yes\nWould you like to use App Router? (recommended) No / Yes\nWould you like to customize the default import alias? No / Yes\nWhat import alias would you like configured? @/*\n在提示之后，create-next-app将创建一个指定项目名称的文件夹，并安装所需的依赖项。\n小贴士:\nNext.js 现在默认有 TypeScript、ESLint 和 Tailwind CSS配置。\n你可以选择性地在项目的根目录中使用 src目录，将应用程序的代码与配置文件分开。","手动安装#手动安装":"要手动创建新的 Next.js 应用，请安装所需的包：\nnpm install next@latest react@latest react-dom@latest\n打开 package.json文件并添加以下 scripts:\n{\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\"\n  }\n}\n这些脚本涉及开发应用的不同阶段：\ndev: 运行 next dev 以在开发模式下启动 Next.js。\nbuild: 运行 next build 以构建用于生产使用的应用。\nstart: 运行 next start 以启动 Next.js 生产服务器。\nlint: 运行 next lint 以设置 Next.js 的内置 ESLint 配置。","创建目录#创建目录":"Next.js 使用文件系统路由，这意味着应用程序中的路由根据构建文件的方式决定。","app-目录#app 目录":"对于新的应用程序，我们建议使用 App 路由。 该路由方式允许你使用 React 的最新特性，它是 Pages 路由 基于社区反馈的演进.创建 app/ 文件夹, 然后添加 layout.tsx 和 page.tsx 文件。 当用户访问应用程序的根路径 (/) 时将会被呈现。\n在 app/layout.tsx 内创建根布局，包含必要的 <html> 和 <body> 标签:\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  );\n}\n最后, 创建一个包含初始内容的主页 app/page.tsx:\nexport default function Page() {\n  return <h1>Hello, Next.js!</h1>;\n}\n小贴士: 如果你忘记创建 layout.tsx，Next.js 会在使用next dev运行开发服务器时自动创建这个文件。\n了解更多关于 使用 the App Router.","pages-目录-可选#pages 目录 (可选)":"如果你更喜欢使用 Pages Router 而不是 App Router，你可以在项目的根目录中创建一个 pages/ 目录。然后，在 pages 文件夹中添加一个 index.tsx 文件。这将是您的主页(/):\nexport default function Page() {\n  return <h1>Hello, Next.js!</h1>;\n}\n接下来，在 pages/ 中添加 _app.tsx 文件以定义全局布局。了解更多有关于 自定义 App 文件。\nimport type { AppProps } from \"next/app\";\nexport default function App({ Component, pageProps }: AppProps) {\n  return <Component {...pageProps} />;\n}\n最后， 在 pages/ 下添加 _document.tsx 文件，以控制来自服务器的初始响应。了解更多关于 自定义 Document 文件。\nimport { Html, Head, Main, NextScript } from \"next/document\";\nexport default function Document() {\n  return (\n    <Html>\n      <Head />\n      <body>\n        <Main />\n        <NextScript />\n      </body>\n    </Html>\n  );\n}\n了解更多关于 使用 Pages Router 。\n小贴士: 虽然可以在同一个项目中使用这两种路由，但是app目录中的路由会比pages目录中的路由有更高的优先级。我们建议在你的新项目中只使用一种路由，以避免引起混淆。","public-文件夹-可选#public 文件夹 (可选)":"创建 public 文件夹用来存储静态资源，如图片、字体等， public 目录下的文件可以通过 base URL (/)来引用。","运行开发服务器#运行开发服务器":"运行 npm run dev 启动开发服务器。\n访问 http://localhost:3000 查看您的应用程序。\n编辑 app/layout.tsx (或 pages/index.tsx) 文件保存并在浏览器中查看更新的结果。"}},"/docs/getting-started/project-structure":{"title":"Next.js 项目结构","data":{"":"本页概述了 Next.js 项目的文件和文件夹结构。它包括顶层文件和文件夹、配置文件以及应用程序和页面目录中的路由约定。","顶层文件夹#顶层文件夹":"app\tApp Router\tpages\tPages Router\tpublic\t静态资源\tsrc\t可选的 src 文件夹","顶层文件#顶层文件":"Next.js\t\tnext.config.js\tNext.js 配置文件\tpackage.json\t项目依赖和脚本\tinstrumentation.ts\tOpenTelemetry and Instrumentation file\tmiddleware.ts\tNext.js 请求中间件\t.env\t环境变量\t.env.local\t本地环境变量\t.env.production\t生产环境变量\t.env.development\t开发环境变量\t.eslintrc.json\tESLint 配置文件\t.gitignore\tGit 忽略配置文件\t.next-env.d.ts\tNext.js TypeScript 声明文件\ttsconfig.json\tTypeScript 配置文件\tjsconfig.json\tJavaScript 配置文件\tpostcss.config.js\tTailwind CSS 配置文件","app-路由约定#app 路由约定":"","路由文件#路由文件":"layout\t.js .jsx .tsx\t布局\tpage\t.js .jsx .tsx\t页面\tloading\t.js .jsx .tsx\t加载页面\tnot-found\t.js .jsx .tsx\t404 页面\terror\t.js .jsx .tsx\t错误 页面\tglobal-error\t.js .jsx .tsx\t全局 页面\troute\t.js .ts\tAPI endpoint\ttemplate\t.js .jsx .tsx\t重新渲染的布局\tdefault\t.js .jsx .tsx\t并行路由回退页面","嵌套路由#嵌套路由":"folder\t路由段\tfolder/folder\t嵌套路由段","动态路由#动态路由":"[folder]\t动态路由段\t[...folder]\t全匹配路由段\t[[...folder]]\t可选全匹配路由段","路由分组和私有文件夹#路由分组和私有文件夹":"(folder)\t对路由进行分组而不影响路由本身\t_folder\t将文件夹和所有子段标记为私有的,不参与路由匹配","并行和拦截路由#并行和拦截路由":"@folder\t命名插槽\t(.)folder\t拦截同级路由\t(..)folder\t拦截上一级路由\t(..)(..)folder\t拦截上两级路由\t(...)folder\t从根路由开始拦截","metadata-文件约定#Metadata 文件约定":"","应用图标#应用图标":"favicon\t.ico\t网站图标文件\ticon\t.ico .jpg .jpeg .png .svg\t应用图标文件\ticon\t.js .ts .tsx\t生成的应用图标文件\tapple-icon\t.jpg .jpeg, .png\tApple 应用图标文件\tapple-icon\t.js .ts .tsx\t生成的 Apple 应用图标文件","open-graph-and-twitter-图片#Open Graph and Twitter 图片":"opengraph-image\t.jpg .jpeg .png .gif\tOpen Graph 图片文件\topengraph-image\t.js .ts .tsx\t生成的 Open Graph 图片文件\ttwitter-image\t.jpg .jpeg .png .gif\tTwitter 图片文件\ttwitter-image\t.js .ts .tsx\t生成的 Twitter 图片文件","seo#SEO":"sitemap\t.xml\tSitemap 文件\tsitemap\t.js .ts\t生成的 Sitemap 文件\trobots\t.txt\tRobots 文件\trobots\t.js .ts\t生成的 Robots 文件","pages-路由约定#pages 路由约定":"","特殊文件#特殊文件":"_app\t.js .jsx .tsx\t定制 App\t_document\t.js .jsx .tsx\t定制 Document\t_error\t.js .jsx .tsx\t定制 错误页面\t404\t.js .jsx .tsx\t404 错误页面\t500\t.js .jsx .tsx\t500 错误页面","路由#路由":"文件夹约定\t\t\tindex\t.js .jsx .tsx\t主页面\tfolder/index\t.js .jsx .tsx\t嵌套页面\t文件约定\t\t\tindex\t.js .jsx .tsx\t主页面\tfile\t.js .jsx .tsx\t嵌套页面","动态路由-1#动态路由":"文件夹约定\t\t\t[folder]/index\t.js .jsx .tsx\t动态路由段\t[...folder]/index\t.js .jsx .tsx\t全捕获路由段\t[[...folder]]/index\t.js .jsx .tsx\t可选全捕获路由段\t文件约定\t\t\t[file]\t.js .jsx .tsx\t动态路由段\t[...file]\t.js .jsx .tsx\t全捕获路由段\t[[...file]]\t.js .jsx .tsx\t可选全捕获路由段"}},"/docs":{"title":"简介","data":{"":"欢迎阅读 Next.js 文档！","什么是-nextjs#什么是 Next.js?":"Next.js 是一个用于构建全栈 web 应用程序的 React 框架。你可以使用 React 组件来构建用户界面，使用 Next.js 获得更多的功能以及优化。在底层，Next.js 还抽象并自动配置了 React 所需的工具链，如打包、编译等。这让你可以专注于构建应用程序，而不需要花时间在配置上。无论你是个人开发者还是大型团队的一员，Next.js 都能帮你构建出交互式、动态和快速的 React 应用程序。","主要特性#主要特性":"Next.js 的一些主要特性包括：\n特性\t描述\t路由\t基于文件系统的路由，且建立在 Server Components 之上，支持布局、嵌套路由、加载状态、错误处理等功能\t渲染\t使用 Client 和 Server Components 进行客户端和服务器端渲染，通过 Next.js 在服务端的静态和动态渲染进一步优化。在 Edge 和 Node.js 运行时支持流式渲染(Streaming )。\t数据获取\t在 Server Components 中使用 async/await 简化了数据获取方式，以及扩展的 fetch API 用于请求缓存、数据缓存和重新验证。\t样式\t支持你选择样式方案，包括 CSS Modules，Tailwind CSS，和 CSS-in-JS。\t优化\tImage，Fonts 和 Script 优化以改善应用程序的 Core Web Vitals 和用户体验。\tTypeScript\t改进了对 TypeScript 的支持，包括更好的类型检查和更高效的编译，以及自定义 TypeScript 插件和类型检查器。","如何使用文档#如何使用文档":"在屏幕左侧，可以看到文档导航栏。文档页面按从基础到高级的顺序排列，因此你可以在构建应用程序时逐步阅读。不过你也可以按照任何顺序阅读文档，或跳转到适用于你的用例的页面。在屏幕右侧，可以看到一个目录，可以更方便地在页面各部分之间进行导航。如果需要快速查找页面，可以使用顶部的搜索栏或搜索快捷键（Ctrl+K 或 Cmd+K）。要开始使用，请查看 安装 指南。","app-router-和-pages-router#App Router 和 Pages Router":"Next.js 有两种不同的路由: App Router 和 Pages Router。 App Router 是一种较新的路由方式，允许你使用 React 的最新特性，如 Server Components 和 Streaming。Pages Router 是最初的 Next.js 路由方式, 允许你构建服务器渲染的 React 应用程序，并继续支持现有的 Next.js 应用程序.在侧边栏的顶部，你会发现一个下拉菜单，允许你在 App Router 和 Pages Router 之间切换。由于每个目录都有独特的功能，因此跟踪选择了哪个选项卡非常重要。\n本站暂未实现 Router 切换功能\n页面顶部的面包屑也将指示你正在查看 App Router 文档还是 Pages Router 文档。","必备知识#必备知识":"虽然我们的文档旨在为初学者提供方便，但我们需要建立一个基准，以便文档能始终专注于 Next.js 的功能。我们将确保在引入新概念时提供相关文档的链接。要充分利用我们的文档，建议你对 HTML、CSS 和 React 有基本的了解。如果你需要补习 React 技能，请查看我们的 Next.js 基础课程，它将为你介绍基础知识。","无障碍#无障碍":"为了在阅读文档时使用屏幕阅读器获得最佳辅助功能，我们建议使用 Firefox 和 NVDA，或 Safari 和 VoiceOver。","加入我们的社区#加入我们的社区":"如果您对 Next.js 有任何疑问，欢迎随时在 GitHub Discussions，Discord，Twitter 和 Reddit 上提问。"}},"/docs/instructions":{"title":"翻译说明","data":{"":"最近在学习 Next.js，发现社区好像并没有对应的文档翻译，所以自己尝试一下翻译。Next.js 官网文档的源码是私有的，所以只能自己开发，当前的网站基于 Nextra 进行开发，能实现官网文档的基本功能。App Router 和 Pages Router 的内容暂时没有翻译，数量有点多 😰其他的已翻译完毕 😀🚧 还未实现的:\n目录支持 切换 App Router 和 Page Router\n搜索支持 切换 App Router 和 Page Router\nApp Router 和 Pages Router 之间复用页面 以及 <AppOnly> 和 <PagesOnly> 区分内容\n原文档的仓库地址\n.\r\n│  index.mdx\r\n│\r\n├─01-getting-started\r\n│      01-installation.mdx\r\n│      02-project-structure.mdx\r\n│      index.mdx\r\n│\r\n├─02-app\r\n│  │  index.mdx\r\n│  │\r\n│  ├─01-building-your-application(54-51) // (文件数量-大于1kb的数量)\r\n│  │\r\n│  └─02-api-reference(83-62)\r\n│\r\n├─03-pages\r\n│  │  index.mdx\r\n│  │\r\n│  ├─01-building-your-application(69-37)\r\n│  │\r\n│  └─02-api-reference(50-10)\r\n│\r\n├─04-architecture\r\n│      accessibility.mdx\r\n│      fast-refresh.mdx\r\n│      index.mdx\r\n│      nextjs-compiler.mdx\r\n│      supported-browsers.mdx\r\n│      turbopack.mdx\r\n│\r\n└─05-community\r\n        01-contribution-guide.mdx\r\n        index.mdx"}},"/docs/pages":{"title":"Pages Router","data":{"":"在 Next.js 13 之前，Pages Router 是在 Next.js 中创建路由的主要方式。它使用文件系统路由器将每个文件映射到路由。Pages Router 在较新版本的 Next.js 中仍然支持，但我们建议迁移到新的 App Router 以使用 React 的最新特性。对于使用 Pages Router 的现有应用程序，请使用文档的此部分。"}},"/":{"title":"Next.js","data":{}},"/docs/architecture/supported-browsers":{"title":"支持的浏览器","data":{"":"Next.js 无需任何配置即可支持现代浏览器。\nChrome 64+ - Chrome 浏览器 64+\nEdge 79+ - 边缘 79+\nFirefox 67+\nOpera 51+\nSafari 12+","browserslist#Browserslist":"如果你想要针对特定的浏览器或特性，Next.js 支持在 package.json 文件中使用 Browserslist 配置。Next.js 默认使用以下 Browserslist 配置:\n{\n  \"browserslist\": [\n    \"chrome 64\"，\n    \"edge 79\"，\n    \"firefox 67\"，\n    \"opera 51\"，\n    \"safari 12\"\n  ]\n}","polyfills#Polyfills":"我们注入了 常用的 polyfills，包括:\nfetch() — 代替: whatwg-fetch 和 unfetch.\nURL — 代替: the url package (Node.js API).\nObject.assign() — 替代 : object-assign， object.assign 和 core-js/object/assign。\n如果你的任何依赖项包含这些 polyfill，它们会在生产版本中自动排除，以避免重复。此外，为了减小包的大小，Next.js 只会为需要它们的浏览器加载这些 polyfill。全球大部分的网络流量都不会下载这些 polyfill。","自定义-polyfill#自定义 Polyfill":"如果你自己的代码或任何外部 npm 依赖项需要目标浏览器不支持的功能(如 IE 11)，你就需要自己添加 polyfill。在这种情况下，你应该在自定义<App> 组件或单独的组件中，添加特定 polyfill 的顶层导入语句。","javascript-语言特性#JavaScript 语言特性":"Next.js 允许你开箱即用最新的 JavaScript 特性。除了 ES6 特性 之外，Next.js 还支持:\nAsync/await (ES2017)\nObject Rest/Spread Properties (ES2018)\nDynamic import() (ES2020)\nOptional Chaining (ES2020)\nNullish Coalescing (ES2020)\nClass Fields 和 Static Properties (part of stage 3 proposal)\n等","服务器端-polyfills#服务器端 Polyfills":"除了在客户端的 fetch() 之外，Next.js 还在 Node.js 环境中(尚未可用) polyfill 了 fetch()。它使用 undici，与 Node.js 本身使用的实现相同。你可以在服务器代码中(如 getStaticProps/getServerSideProps)使用 fetch()，而无需使用像 isomorphic-unfetch 和 node-fetch 这样的 polyfill。","typescript-特性#TypeScript 特性":"Next.js 内置了 TypeScript 支持。 了解更多。","自定义-babel-配置高级#自定义 Babel 配置(高级)":"你可以自定义 babel 配置。 了解更多。"}},"/docs/architecture/nextjs-compiler":{"title":"Next.js 编译器","data":{"":"Next.js 编译器是使用 SWC 用 Rust 编写的，它允许 Next.js 转译和压缩 JavaScript 代码以用于生产。它取代了用于单个文件的 Babel 和用于代码压缩的 Terser。使用 Next.js 编译器进行编译的速度是 Babel 的 17 倍，并且从 Next.js 第 12 版开始默认启用。如果你已有 Babel 配置或正在使用不支持的特性，你的应用程序将选择不使用 Next.js 编译器，而继续使用 Babel。","为什么选择-swc#为什么选择 SWC?":"SWC 是下一代快速开发者工具的可扩展基于 Rust 的平台。SWC 可以用于编译、最小化、打包等,并且设计了可扩展性。它可以被调用来执行代码转换(无论是内置的还是自定义的)。这些转换的执行是通过 Next.js 等更高级别的工具来完成的。我们选择基于 SWC 构建的几个原因:\n可扩展性: SWC 可以作为 Crate 在 Next.js 内部使用,而不需要 fork 该库或解决设计约束。\n性能: 通过切换到 SWC,我们能在 Next.js 中实现约 3 倍的快速刷新速度和 5 倍的构建速度,优化空间还在持续扩大。\nWebAssembly: Rust 对 WASM 的支持对支持所有可能的平台和将 Next.js 开发带到任何地方至关重要。\n社区: Rust 社区和生态系统令人惊叹且还在不断增长。","支持的特性#支持的特性":"","styled-components#Styled Components":"We're working to port babel-plugin-styled-components to the Next.js Compiler.First, update to the latest version of Next.js: npm install next@latest. Then, update your next.config.js file:\nmodule.exports = {\n  compiler: {\n    // see https://styled-components.com/docs/tooling#babel-plugin for more info on the options.\n    styledComponents: boolean | {\n      // Enabled by default in development, disabled in production to reduce file size,\n      // setting this will override the default for all environments.\n      displayName?: boolean,\n      // Enabled by default.\n      ssr?: boolean,\n      // Enabled by default.\n      fileName?: boolean,\n      // Empty by default.\n      topLevelImportPaths?: string[],\n      // Defaults to [\"index\"].\n      meaninglessFileNames?: string[],\n      // Enabled by default.\n      cssProp?: boolean,\n      // Empty by default.\n      namespace?: string,\n      // Not supported yet.\n      minify?: boolean,\n      // Not supported yet.\n      transpileTemplateLiterals?: boolean,\n      // Not supported yet.\n      pure?: boolean,\n    },\n  },\n}\nminify, transpileTemplateLiterals and pure are not yet implemented. You can follow the progress here. ssr and displayName transforms are the main requirement for using styled-components in Next.js.","jest#Jest":"The Next.js Compiler transpiles your tests and simplifies configuring Jest together with Next.js including:\nAuto mocking of .css, .module.css (and their .scss variants), and image imports\nAutomatically sets up transform using SWC\nLoading .env (and all variants) into process.env\nIgnores node_modules from test resolving and transforms\nIgnoring .next from test resolving\nLoads next.config.js for flags that enable experimental SWC transforms\nFirst, update to the latest version of Next.js: npm install next@latest. Then, update your jest.config.js file:\nconst nextJest = require(\"next/jest\");\n// Providing the path to your Next.js app which will enable loading next.config.js and .env files\nconst createJestConfig = nextJest({ dir: \"./\" });\n// Any custom config you want to pass to Jest\nconst customJestConfig = {\n  setupFilesAfterEnv: [\"<rootDir>/jest.setup.js\"],\n};\n// createJestConfig is exported in this way to ensure that next/jest can load the Next.js configuration, which is async\nmodule.exports = createJestConfig(customJestConfig);","relay#Relay":"To enable Relay support:\nmodule.exports = {\n  compiler: {\n    relay: {\n      // This should match relay.config.js\n      src: \"./\",\n      artifactDirectory: \"./__generated__\",\n      language: \"typescript\",\n      eagerEsModules: false,\n    },\n  },\n};\nGood to know: In Next.js, all JavaScript files in pages directory are considered routes. So, for relay-compiler you'll need to specify artifactDirectory configuration settings outside of the pages, otherwise relay-compiler will generate files next to the source file in the __generated__ directory, and this file will be considered a route, which will break production builds.","remove-react-properties#Remove React Properties":"Allows to remove JSX properties. This is often used for testing. Similar to babel-plugin-react-remove-properties.To remove properties matching the default regex ^data-test:\nmodule.exports = {\n  compiler: {\n    reactRemoveProperties: true,\n  },\n};\nTo remove custom properties:\nmodule.exports = {\n  compiler: {\n    // The regexes defined here are processed in Rust so the syntax is different from\n    // JavaScript `RegExp`s. See https://docs.rs/regex.\n    reactRemoveProperties: { properties: [\"^data-custom$\"] },\n  },\n};","remove-console#Remove Console":"This transform allows for removing all console.* calls in application code (not node_modules). Similar to babel-plugin-transform-remove-console.Remove all console.* calls:\nmodule.exports = {\n  compiler: {\n    removeConsole: true,\n  },\n};\nRemove console.* output except console.error:\nmodule.exports = {\n  compiler: {\n    removeConsole: {\n      exclude: [\"error\"],\n    },\n  },\n};","legacy-decorators#Legacy Decorators":"Next.js will automatically detect experimentalDecorators in jsconfig.json or tsconfig.json. Legacy decorators are commonly used with older versions of libraries like mobx.This flag is only supported for compatibility with existing applications. We do not recommend using legacy decorators in new applications.First, update to the latest version of Next.js: npm install next@latest. Then, update your jsconfig.json or tsconfig.json file:\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true\n  }\n}","importsource#importSource":"Next.js will automatically detect jsxImportSource in jsconfig.json or tsconfig.json and apply that. This is commonly used with libraries like Theme UI.First, update to the latest version of Next.js: npm install next@latest. Then, update your jsconfig.json or tsconfig.json file:\n{\n  \"compilerOptions\": {\n    \"jsxImportSource\": \"theme-ui\"\n  }\n}","emotion#Emotion":"We're working to port @emotion/babel-plugin to the Next.js Compiler.First, update to the latest version of Next.js: npm install next@latest. Then, update your next.config.js file:\nmodule.exports = {\n  compiler: {\n    emotion: boolean | {\n      // default is true. It will be disabled when build type is production.\n      sourceMap?: boolean,\n      // default is 'dev-only'.\n      autoLabel?: 'never' | 'dev-only' | 'always',\n      // default is '[local]'.\n      // Allowed values: `[local]` `[filename]` and `[dirname]`\n      // This option only works when autoLabel is set to 'dev-only' or 'always'.\n      // It allows you to define the format of the resulting label.\n      // The format is defined via string where variable parts are enclosed in square brackets [].\n      // For example labelFormat: \"my-classname--[local]\", where [local] will be replaced with the name of the variable the result is assigned to.\n      labelFormat?: string,\n      // default is undefined.\n      // This option allows you to tell the compiler what imports it should\n      // look at to determine what it should transform so if you re-export\n      // Emotion's exports, you can still use transforms.\n      importMap?: {\n        [packageName: string]: {\n          [exportName: string]: {\n            canonicalImport?: [string, string],\n            styledBaseImport?: [string, string],\n          }\n        }\n      },\n    },\n  },\n}","minification#Minification":"Next.js' swc compiler is used for minification by default since v13. This is 7x faster than Terser.If Terser is still needed for any reason this can be configured.\nmodule.exports = {\n  swcMinify: false,\n};","module-transpilation#Module Transpilation":"Next.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (node_modules). This replaces the next-transpile-modules package.\nmodule.exports = {\n  transpilePackages: [\"@acme/ui\", \"lodash-es\"],\n};","modularize-imports#Modularize Imports":"Examples\nmodularize-imports\nAllows to modularize imports, similar to babel-plugin-transform-imports.Transforms member style imports of packages that use a “barrel file” (a single file that re-exports other modules):\nimport { Row, Grid as MyGrid } from \"react-bootstrap\";\nimport { merge } from \"lodash\";\n...into default style imports of each module. This prevents compilation of unused modules:\nimport Row from \"react-bootstrap/Row\";\nimport MyGrid from \"react-bootstrap/Grid\";\nimport merge from \"lodash/merge\";\nConfig for the above transform:\nmodule.exports = {\n  modularizeImports: {\n    \"react-bootstrap\": {\n      transform: \"react-bootstrap/{{member}}\",\n    },\n    lodash: {\n      transform: \"lodash/{{member}}\",\n    },\n  },\n};","handlebars-variables-and-helper-functions#Handlebars variables and helper functions":"This transform uses handlebars to template the replacement import path in the transform field. These variables and helper functions are available:\nmember: Has type string. The name of the member import.\nlowerCase, upperCase, camelCase, kebabCase: Helper functions to convert a string to lower, upper, camel or kebab cases.\nmatches: Has type string[]. All groups matched by the regular expression. matches.[0] is the full match.\nFor example, you can use the kebabCase helper like this:\nmodule.exports = {\n  modularizeImports: {\n    \"my-library\": {\n      transform: \"my-library/{{ kebabCase member }}\",\n    },\n  },\n};\nThe above config will transform your code as follows:\n// Before\nimport { MyModule } from \"my-library\";\n// After (`MyModule` was converted to `my-module`)\nimport MyModule from \"my-library/my-module\";\nYou can also use regular expressions using Rust regex crate’s syntax:\nmodule.exports = {\n  modularizeImports: {\n    \"my-library/?(((\\\\w*)?/?)*)\": {\n      transform: \"my-library/{{ matches.[1] }}/{{member}}\",\n    },\n  },\n};\nThe above config will transform your code as follows:\n// Before\nimport { MyModule } from \"my-library\";\nimport { App } from \"my-library/components\";\nimport { Header, Footer } from \"my-library/components/app\";\n// After\nimport MyModule from \"my-library/my-module\";\nimport App from \"my-library/components/app\";\nimport Header from \"my-library/components/app/header\";\nimport Footer from \"my-library/components/app/footer\";","using-named-imports#Using named imports":"By default, modularizeImports assumes that each module uses default exports. However, this may not always be the case — named exports may be used.\n// Using named export instead of default export\nexport const MyModule = {};\n// my-library/index.ts\n// The “barrel file” that re-exports `MyModule`\nexport { MyModule } from \"./MyModule\";\nIn this case, you can use the skipDefaultConversion option to use named imports instead of default imports:\nmodule.exports = {\n  modularizeImports: {\n    \"my-library\": {\n      transform: \"my-library/{{member}}\",\n      skipDefaultConversion: true,\n    },\n  },\n};\nThe above config will transform your code as follows:\n// Before\nimport { MyModule } from \"my-library\";\n// After (imports `MyModule` using named import)\nimport { MyModule } from \"my-library/MyModule\";","preventing-full-import#Preventing full import":"If you use the preventFullImport option, the compiler will throw an error if you import a “barrel file” using default import. If you use the following config:\nmodule.exports = {\n  modularizeImports: {\n    lodash: {\n      transform: \"lodash/{{member}}\",\n      preventFullImport: true,\n    },\n  },\n};\nThe compiler will throw an error if you try to import the full lodash library (instead of using named imports):\n// Compiler error\nimport lodash from \"lodash\";","实验性特性#实验性特性":"","swc-trace-profiling#SWC Trace profiling":"You can generate SWC's internal transform traces as chromium's trace event format.\nmodule.exports = {\n  experimental: {\n    swcTraceProfiling: true,\n  },\n};\nOnce enabled, swc will generate trace named as swc-trace-profile-${timestamp}.json under .next/. Chromium's trace viewer (chrome://tracing/, https://ui.perfetto.dev/), or compatible flamegraph viewer (https://www.speedscope.app/) can load & visualize generated traces.","swc-插件-实验性#SWC 插件 (实验性)":"你可以配置 swc 的转换，以使用 wasm 编写的 SWC 实验插件支持来定制转换行为。\nmodule.exports = {\n  experimental: {\n    swcPlugins: [\n      [\n        \"plugin\",\n        {\n          ...pluginOptions,\n        },\n      ],\n    ],\n  },\n};\nswcPlugins 接受用于配置插件的元组数组。插件的元组包含插件的路径和用于插件配置的对象。插件的路径可以是 npm 模块包名，也可以是 .wasm 二进制文件本身的绝对路径。","不支持的特性#不支持的特性":"当你的应用程序有一个 .babelrc 文件时，Next.js 会自动回退到使用 Babel 来转换单个文件。这确保了向后兼容性，以支持利用自定义 Babel 插件的现有应用程序。如果你正在使用自定义的 Babel 设置，请分享你的配置。我们正在努力移植尽可能多常用的 Babel 转换，以及在未来支持插件。","版本历史#版本历史":"版本\t变化\tv13.1.0\tModule Transpilation and Modularize Imports stable.\tv13.0.0\tSWC Minifier enabled by default.\tv12.3.0\tSWC Minifier stable.\tv12.2.0\tSWC Plugins experimental support added.\tv12.1.0\tAdded support for Styled Components, Jest, Relay, Remove React Properties, Legacy Decorators, Remove Console, and jsxImportSource.\tv12.0.0\tNext.js Compiler introduced."}}}